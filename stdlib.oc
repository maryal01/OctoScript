fn overload fold_left(lambda<int, int => int> f, int acc, list<int> li) -> int {
    int i = 0;
    int res = acc;
    while(i < li.length()){
        res = f(res, li.get(i));
        i = i + 1;
    }
    return res;
}

fn overload fold_left(lambda<float, float => float> f, float acc, list<float> li) -> float {
    int i = 0;
    float res = acc;
    while(i < li.length()){
        res = f(res, li.get(i));
        i = i + 1;
    }
    return res;
}

fn overload sum(list<int> l) -> int {
    return fold_left(fn (int a, int e) => {a + e}, 0, l);
}

fn overload sum(list<float> l) -> float {
    return fold_left(fn (float a, float e) => {a + e}, 0.0, l);
}

fn overload max (list<int> li) -> int {
    int max = li.get(0);
    int i = 1;
    while (i < li.length()) {
        int v = li.get(i);
        if (v > max){
            max = v; 
        }
        i = i + 1;
    }
    return max;
}

fn overload max (list<float> lf) -> float {
    float max = lf.get(0);
    int i = 1;
    while (i < lf.length()) {
        float v = lf.get(i);
        if (v > max){
            max = v; 
        }
        i = i + 1;
    }
    return max;
}
fn overload min (list<int> li) -> int {
    int min = li.get(0);
    int i = 1;
    while (i < li.length()) {
        int v = li.get(i);
        if (v < min){
            min = v; 
        }
        i = i + 1;
    }
    return min;
}

fn overload min (list<float> lf) -> float {
    float min = lf.get(0);
    int i = 1;
    while (i < lf.length()) {
        float v = lf.get(i);
        if (v < min){
            min = v; 
        }
        i = i + 1;
    }
    return min;
}

fn partition( list<int> arr, int l, int h, lambda<int, int => bool> cmp ) -> int {
    int i =  l - 1;
    int x = arr.get(h);
    int j = l;
    while ( j < h ){
        int temp = arr.get(j);
        if (cmp(temp, x)) {
            i = i + 1;
            int arr_i = arr.get(i);
            int arr_j = arr.get(j);
            arr.replace(j, arr_i);
            arr.replace(i, arr_j);
        }
        j = j + 1;
    }
    int idx = i + 1;
    int arr_i1 = arr.get(idx);
    
    int arr_h = arr.get(h);
    arr.replace(idx, arr_h);
    arr.replace(h, arr_i1);

    return idx;
}

fn overload sort(list<int> arr, lambda<int, int => bool> cmp ) -> none{
    list<int> stack = [0, 0, 0, 0, 0, 0, 0, 0];

    int n = arr.length();
    int l = 0;
    int h = n - 1;

    /* initialize top of stack */
    int top = -1;

    /* push initial values of l and h to stack */
    top = top + 1;
    stack.replace(top, l);
    top = top + 1;
    stack.replace(top, h);

    /* Keep popping from stack while is not empty */
    while (top >= 0){
        /* Pop h and l */
        h = stack.get(top);
        top = top - 1;
        l = stack.get(top);
        top = top - 1;

        /* Set pivot element at its correct position in sorted array */
        int p = partition( arr, l, h, cmp );

        int new_val = p - 1;
        /* If there are elements on left side of pivot, then push left side to stack */
        if (new_val > l){
            top = top + 1;
            stack.replace(top, l);
            top = top + 1;
            stack.replace(top, new_val);
        }

        new_val = p + 1;
        /* If there are elements on right side of pivot, then push right side to stack */
        if ( new_val < h ) {
            top = top + 1;
            stack.replace(top, new_val);
            top = top + 1;
            stack.replace(top, h);
        }
    }
}

/*
fn overload sort(list<string> i, lambda<string, string => bool> p){
    
}*/